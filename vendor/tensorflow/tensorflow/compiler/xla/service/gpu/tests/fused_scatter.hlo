// RUN: hlo_to_llvm_ir %s | FileCheck %s

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// CHECK-LABEL: entry:
// CHECK:         %[[VAL_0:.*]] = getelementptr inbounds i8, ptr %[[VAL_1:.*]], i64 0
// CHECK:         %[[VAL_2:.*]] = getelementptr inbounds i8, ptr %[[VAL_3:.*]], i64 128
// CHECK:         br label %[[VAL_4:.*]]
// CHECK:       2:                                                ; preds = %[[VAL_5:.*]]
// CHECK:         %[[VAL_6:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x()
// CHECK:         %[[VAL_7:.*]] = getelementptr i32, ptr %[[VAL_0]], i32 %[[VAL_6]]
// CHECK:         %[[VAL_8:.*]] = load i32, ptr %[[VAL_7]], align 4
// CHECK:         %[[VAL_9:.*]] = add i32 %[[VAL_8]], %[[VAL_8]]
// CHECK:         %[[VAL_10:.*]] = getelementptr i32, ptr %[[VAL_2]], i32 %[[VAL_6]]
// CHECK:         store i32 %[[VAL_9]], ptr %[[VAL_10]], align 4
// CHECK:         ret void
// CHECK:       entry:
// CHECK:         %[[VAL_11:.*]] = getelementptr inbounds i8, ptr %[[VAL_12:.*]], i64 0
// CHECK:         %[[VAL_13:.*]] = getelementptr inbounds i8, ptr %[[VAL_14:.*]], i64 0
// CHECK:         br label %[[VAL_15:.*]]
// CHECK:       2:                                                ; preds = %[[VAL_16:.*]]
// CHECK:         %[[VAL_17:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x()
// CHECK:         %[[VAL_18:.*]] = getelementptr i32, ptr %[[VAL_11]], i32 %[[VAL_17]]
// CHECK:         %[[VAL_19:.*]] = load i32, ptr %[[VAL_18]], align 4
// CHECK:         %[[VAL_20:.*]] = add i32 %[[VAL_19]], %[[VAL_19]]
// CHECK:         %[[VAL_21:.*]] = getelementptr i32, ptr %[[VAL_13]], i32 %[[VAL_17]]
// CHECK:         store i32 %[[VAL_20]], ptr %[[VAL_21]], align 4
// CHECK:         ret void
// CHECK:       entry:
// CHECK:         %[[VAL_22:.*]] = getelementptr inbounds i8, ptr %[[VAL_23:.*]], i64 0
// CHECK:         %[[VAL_24:.*]] = getelementptr inbounds i8, ptr %[[VAL_25:.*]], i64 0
// CHECK:         br label %[[VAL_26:.*]]
// CHECK:       2:                                                ; preds = %[[VAL_27:.*]]
// CHECK:         %[[VAL_28:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x()
// CHECK:         %[[VAL_29:.*]] = getelementptr i32, ptr %[[VAL_22]], i32 %[[VAL_28]]
// CHECK:         %[[VAL_30:.*]] = load i32, ptr %[[VAL_29]], align 4
// CHECK:         %[[VAL_31:.*]] = add i32 %[[VAL_30]], %[[VAL_30]]
// CHECK:         %[[VAL_32:.*]] = getelementptr i32, ptr %[[VAL_24]], i32 %[[VAL_28]]
// CHECK:         store i32 %[[VAL_31]], ptr %[[VAL_32]], align 4
// CHECK:         ret void
// CHECK:       entry:
// CHECK:         %[[VAL_33:.*]] = alloca i32, align 4
// CHECK:         %[[VAL_34:.*]] = getelementptr inbounds i8, ptr %[[VAL_35:.*]], i64 128
// CHECK:         %[[VAL_36:.*]] = getelementptr inbounds i8, ptr %[[VAL_35]], i64 0
// CHECK:         %[[VAL_37:.*]] = getelementptr inbounds i8, ptr %[[VAL_38:.*]], i64 0
// CHECK:         %[[VAL_39:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !11
// CHECK:         %[[VAL_40:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !12
// CHECK:         %[[VAL_41:.*]] = mul nuw nsw i32 %[[VAL_39]], 6
// CHECK:         %[[VAL_42:.*]] = add nuw nsw i32 %[[VAL_41]], %[[VAL_40]]
// CHECK:         %[[VAL_43:.*]] = icmp ult i32 %[[VAL_42]], 6
// CHECK:         call void @llvm.assume(i1 %[[VAL_43]])
// CHECK:         %[[VAL_44:.*]] = udiv i32 %[[VAL_42]], 1
// CHECK:         %[[VAL_45:.*]] = urem i32 %[[VAL_44]], 3
// CHECK:         %[[VAL_46:.*]] = udiv i32 %[[VAL_42]], 3
// CHECK:         %[[VAL_47:.*]] = icmp ult i32 %[[VAL_42]], 6
// CHECK:         br i1 %[[VAL_47]], label %[[VAL_48:.*]], label %[[VAL_49:.*]]
// CHECK:       scatter.in_bounds-after:                          ; preds = %[[VAL_50:.*]], %[[VAL_51:.*]]
// CHECK:         ret void
// CHECK:       scatter.in_bounds-true:                           ; preds = %[[VAL_51]]
// CHECK:         %[[VAL_52:.*]] = getelementptr inbounds [2 x i32], ptr %[[VAL_34]], i32 0, i32 %[[VAL_46]]
// CHECK:         %[[VAL_53:.*]] = load i32, ptr %[[VAL_52]], align 4, !invariant.load !13
// CHECK:         %[[VAL_54:.*]] = add i32 0, %[[VAL_53]]
// CHECK:         %[[VAL_55:.*]] = icmp ult i32 %[[VAL_53]], 3
// CHECK:         %[[VAL_56:.*]] = and i1 true, %[[VAL_55]]
// CHECK:         br i1 %[[VAL_56]], label %[[VAL_57:.*]], label %[[VAL_50]]
// CHECK:       scatter.in_bounds-after3:                         ; preds = %[[VAL_57]], %[[VAL_48]]
// CHECK:         br label %[[VAL_49]]
// CHECK:       scatter.in_bounds-true2:                          ; preds = %[[VAL_48]]
// CHECK:         %[[VAL_58:.*]] = getelementptr inbounds [3 x [3 x i32]], ptr %[[VAL_37]], i32 0, i32 %[[VAL_54]], i32 %[[VAL_45]]
// CHECK:         %[[VAL_59:.*]] = getelementptr inbounds i32, ptr %[[VAL_36]], i32 %[[VAL_42]]
// CHECK:         %[[VAL_60:.*]] = load i32, ptr %[[VAL_59]], align 4, !invariant.load !13
// CHECK:         store i32 %[[VAL_60]], ptr %[[VAL_33]], align 4
// CHECK:         %[[VAL_61:.*]] = load i32, ptr %[[VAL_33]], align 4
// CHECK:         store atomic i32 %[[VAL_61]], ptr %[[VAL_58]] unordered, align 4
// CHECK:         br label %[[VAL_50]]

HloModule TensorFlowScatterV1

update_s32 (lhs: s32[], rhs: s32[]) -> s32[] {
  lhs = s32[] parameter(0)
  ROOT rhs = s32[] parameter(1)
}

ENTRY main {
  p0 = s32[3,3] parameter(0)
  operand = s32[3,3] add(p0, p0)
  p1 = s32[2] parameter(1)
  indices = s32[2] add(p1, p1)
  p2 = s32[2,3] parameter(2)
  updates = s32[2,3] add(p2, p2)
  ROOT scatter = s32[3,3] scatter(operand, indices, updates),
      to_apply=update_s32,
      update_window_dims={1},
      inserted_window_dims={0},
      scatter_dims_to_operand_dims={0},
      index_vector_dim=1
}
