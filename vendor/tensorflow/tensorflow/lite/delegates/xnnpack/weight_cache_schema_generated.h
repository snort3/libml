/* Copyright 2024 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_WEIGHTCACHESCHEMA_TFLITE_XNNPACK_CACHE_SCHEMA_H_
#define FLATBUFFERS_GENERATED_WEIGHTCACHESCHEMA_TFLITE_XNNPACK_CACHE_SCHEMA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace tflite {
namespace xnnpack {
namespace cache {
namespace schema {

struct Buffer;
struct BufferBuilder;
struct BufferT;

struct PackedWeights;
struct PackedWeightsBuilder;
struct PackedWeightsT;

struct BufferT : public ::flatbuffers::NativeTable {
  typedef Buffer TableType;
  uint64_t packing_algorithm_id = 0;
  uint64_t weights_id = 0;
  uint64_t bias_id = 0;
  uint64_t offset = 0;
  uint64_t size = 0;
};

struct Buffer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BufferT NativeTableType;
  typedef BufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PACKING_ALGORITHM_ID = 4,
    VT_WEIGHTS_ID = 6,
    VT_BIAS_ID = 8,
    VT_OFFSET = 10,
    VT_SIZE = 12
  };
  uint64_t packing_algorithm_id() const {
    return GetField<uint64_t>(VT_PACKING_ALGORITHM_ID, 0);
  }
  bool mutate_packing_algorithm_id(uint64_t _packing_algorithm_id = 0) {
    return SetField<uint64_t>(VT_PACKING_ALGORITHM_ID, _packing_algorithm_id, 0);
  }
  uint64_t weights_id() const {
    return GetField<uint64_t>(VT_WEIGHTS_ID, 0);
  }
  bool mutate_weights_id(uint64_t _weights_id = 0) {
    return SetField<uint64_t>(VT_WEIGHTS_ID, _weights_id, 0);
  }
  uint64_t bias_id() const {
    return GetField<uint64_t>(VT_BIAS_ID, 0);
  }
  bool mutate_bias_id(uint64_t _bias_id = 0) {
    return SetField<uint64_t>(VT_BIAS_ID, _bias_id, 0);
  }
  /// The buffer data is appended after the flatbuffer to bypass 2GB file size
  /// limitation. The offset is calculated relative to the base offset.
  /// (i.e. beginning of the file + base_offset).
  uint64_t offset() const {
    return GetField<uint64_t>(VT_OFFSET, 0);
  }
  bool mutate_offset(uint64_t _offset = 0) {
    return SetField<uint64_t>(VT_OFFSET, _offset, 0);
  }
  /// Size of the buffer in bytes.
  uint64_t size() const {
    return GetField<uint64_t>(VT_SIZE, 0);
  }
  bool mutate_size(uint64_t _size = 0) {
    return SetField<uint64_t>(VT_SIZE, _size, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PACKING_ALGORITHM_ID, 8) &&
           VerifyField<uint64_t>(verifier, VT_WEIGHTS_ID, 8) &&
           VerifyField<uint64_t>(verifier, VT_BIAS_ID, 8) &&
           VerifyField<uint64_t>(verifier, VT_OFFSET, 8) &&
           VerifyField<uint64_t>(verifier, VT_SIZE, 8) &&
           verifier.EndTable();
  }
  BufferT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BufferT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Buffer> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BufferT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BufferBuilder {
  typedef Buffer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_packing_algorithm_id(uint64_t packing_algorithm_id) {
    fbb_.AddElement<uint64_t>(Buffer::VT_PACKING_ALGORITHM_ID, packing_algorithm_id, 0);
  }
  void add_weights_id(uint64_t weights_id) {
    fbb_.AddElement<uint64_t>(Buffer::VT_WEIGHTS_ID, weights_id, 0);
  }
  void add_bias_id(uint64_t bias_id) {
    fbb_.AddElement<uint64_t>(Buffer::VT_BIAS_ID, bias_id, 0);
  }
  void add_offset(uint64_t offset) {
    fbb_.AddElement<uint64_t>(Buffer::VT_OFFSET, offset, 0);
  }
  void add_size(uint64_t size) {
    fbb_.AddElement<uint64_t>(Buffer::VT_SIZE, size, 0);
  }
  explicit BufferBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Buffer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Buffer> CreateBuffer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t packing_algorithm_id = 0,
    uint64_t weights_id = 0,
    uint64_t bias_id = 0,
    uint64_t offset = 0,
    uint64_t size = 0) {
  BufferBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_offset(offset);
  builder_.add_bias_id(bias_id);
  builder_.add_weights_id(weights_id);
  builder_.add_packing_algorithm_id(packing_algorithm_id);
  return builder_.Finish();
}

::flatbuffers::Offset<Buffer> CreateBuffer(::flatbuffers::FlatBufferBuilder &_fbb, const BufferT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PackedWeightsT : public ::flatbuffers::NativeTable {
  typedef PackedWeights TableType;
  std::vector<std::unique_ptr<tflite::xnnpack::cache::schema::BufferT>> buffers{};
  uint64_t flatbuffer_size = 0;
  uint64_t base_offset = 0;
  PackedWeightsT() = default;
  PackedWeightsT(const PackedWeightsT &o);
  PackedWeightsT(PackedWeightsT&&) FLATBUFFERS_NOEXCEPT = default;
  PackedWeightsT &operator=(PackedWeightsT o) FLATBUFFERS_NOEXCEPT;
};

struct PackedWeights FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PackedWeightsT NativeTableType;
  typedef PackedWeightsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BUFFERS = 4,
    VT_FLATBUFFER_SIZE = 6,
    VT_BASE_OFFSET = 8
  };
  /// A list of buffers.
  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::xnnpack::cache::schema::Buffer>> *buffers() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::xnnpack::cache::schema::Buffer>> *>(VT_BUFFERS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<tflite::xnnpack::cache::schema::Buffer>> *mutable_buffers() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<tflite::xnnpack::cache::schema::Buffer>> *>(VT_BUFFERS);
  }
  /// The serialized file is `flatbuffer_size` of bytes representing
  /// `NamedBuffers` appended with a blob representing the buffer content.
  uint64_t flatbuffer_size() const {
    return GetField<uint64_t>(VT_FLATBUFFER_SIZE, 0);
  }
  bool mutate_flatbuffer_size(uint64_t _flatbuffer_size = 0) {
    return SetField<uint64_t>(VT_FLATBUFFER_SIZE, _flatbuffer_size, 0);
  }
  /// Defines the base offset for the data appended to the file. That offset
  /// may be needed to guarantee data alignment.
  uint64_t base_offset() const {
    return GetField<uint64_t>(VT_BASE_OFFSET, 0);
  }
  bool mutate_base_offset(uint64_t _base_offset = 0) {
    return SetField<uint64_t>(VT_BASE_OFFSET, _base_offset, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BUFFERS) &&
           verifier.VerifyVector(buffers()) &&
           verifier.VerifyVectorOfTables(buffers()) &&
           VerifyField<uint64_t>(verifier, VT_FLATBUFFER_SIZE, 8) &&
           VerifyField<uint64_t>(verifier, VT_BASE_OFFSET, 8) &&
           verifier.EndTable();
  }
  PackedWeightsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PackedWeightsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PackedWeights> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PackedWeightsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PackedWeightsBuilder {
  typedef PackedWeights Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_buffers(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::xnnpack::cache::schema::Buffer>>> buffers) {
    fbb_.AddOffset(PackedWeights::VT_BUFFERS, buffers);
  }
  void add_flatbuffer_size(uint64_t flatbuffer_size) {
    fbb_.AddElement<uint64_t>(PackedWeights::VT_FLATBUFFER_SIZE, flatbuffer_size, 0);
  }
  void add_base_offset(uint64_t base_offset) {
    fbb_.AddElement<uint64_t>(PackedWeights::VT_BASE_OFFSET, base_offset, 0);
  }
  explicit PackedWeightsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PackedWeights> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PackedWeights>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PackedWeights> CreatePackedWeights(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::xnnpack::cache::schema::Buffer>>> buffers = 0,
    uint64_t flatbuffer_size = 0,
    uint64_t base_offset = 0) {
  PackedWeightsBuilder builder_(_fbb);
  builder_.add_base_offset(base_offset);
  builder_.add_flatbuffer_size(flatbuffer_size);
  builder_.add_buffers(buffers);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PackedWeights> CreatePackedWeightsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<tflite::xnnpack::cache::schema::Buffer>> *buffers = nullptr,
    uint64_t flatbuffer_size = 0,
    uint64_t base_offset = 0) {
  auto buffers__ = buffers ? _fbb.CreateVector<::flatbuffers::Offset<tflite::xnnpack::cache::schema::Buffer>>(*buffers) : 0;
  return tflite::xnnpack::cache::schema::CreatePackedWeights(
      _fbb,
      buffers__,
      flatbuffer_size,
      base_offset);
}

::flatbuffers::Offset<PackedWeights> CreatePackedWeights(::flatbuffers::FlatBufferBuilder &_fbb, const PackedWeightsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline BufferT *Buffer::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BufferT>(new BufferT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Buffer::UnPackTo(BufferT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = packing_algorithm_id(); _o->packing_algorithm_id = _e; }
  { auto _e = weights_id(); _o->weights_id = _e; }
  { auto _e = bias_id(); _o->bias_id = _e; }
  { auto _e = offset(); _o->offset = _e; }
  { auto _e = size(); _o->size = _e; }
}

inline ::flatbuffers::Offset<Buffer> Buffer::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BufferT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBuffer(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Buffer> CreateBuffer(::flatbuffers::FlatBufferBuilder &_fbb, const BufferT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BufferT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _packing_algorithm_id = _o->packing_algorithm_id;
  auto _weights_id = _o->weights_id;
  auto _bias_id = _o->bias_id;
  auto _offset = _o->offset;
  auto _size = _o->size;
  return tflite::xnnpack::cache::schema::CreateBuffer(
      _fbb,
      _packing_algorithm_id,
      _weights_id,
      _bias_id,
      _offset,
      _size);
}

inline PackedWeightsT::PackedWeightsT(const PackedWeightsT &o)
      : flatbuffer_size(o.flatbuffer_size),
        base_offset(o.base_offset) {
  buffers.reserve(o.buffers.size());
  for (const auto &buffers_ : o.buffers) { buffers.emplace_back((buffers_) ? new tflite::xnnpack::cache::schema::BufferT(*buffers_) : nullptr); }
}

inline PackedWeightsT &PackedWeightsT::operator=(PackedWeightsT o) FLATBUFFERS_NOEXCEPT {
  std::swap(buffers, o.buffers);
  std::swap(flatbuffer_size, o.flatbuffer_size);
  std::swap(base_offset, o.base_offset);
  return *this;
}

inline PackedWeightsT *PackedWeights::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PackedWeightsT>(new PackedWeightsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PackedWeights::UnPackTo(PackedWeightsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = buffers(); if (_e) { _o->buffers.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->buffers[_i]) { _e->Get(_i)->UnPackTo(_o->buffers[_i].get(), _resolver); } else { _o->buffers[_i] = std::unique_ptr<tflite::xnnpack::cache::schema::BufferT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->buffers.resize(0); } }
  { auto _e = flatbuffer_size(); _o->flatbuffer_size = _e; }
  { auto _e = base_offset(); _o->base_offset = _e; }
}

inline ::flatbuffers::Offset<PackedWeights> PackedWeights::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PackedWeightsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePackedWeights(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PackedWeights> CreatePackedWeights(::flatbuffers::FlatBufferBuilder &_fbb, const PackedWeightsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PackedWeightsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _buffers = _o->buffers.size() ? _fbb.CreateVector<::flatbuffers::Offset<tflite::xnnpack::cache::schema::Buffer>> (_o->buffers.size(), [](size_t i, _VectorArgs *__va) { return CreateBuffer(*__va->__fbb, __va->__o->buffers[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _flatbuffer_size = _o->flatbuffer_size;
  auto _base_offset = _o->base_offset;
  return tflite::xnnpack::cache::schema::CreatePackedWeights(
      _fbb,
      _buffers,
      _flatbuffer_size,
      _base_offset);
}

inline const tflite::xnnpack::cache::schema::PackedWeights *GetPackedWeights(const void *buf) {
  return ::flatbuffers::GetRoot<tflite::xnnpack::cache::schema::PackedWeights>(buf);
}

inline const tflite::xnnpack::cache::schema::PackedWeights *GetSizePrefixedPackedWeights(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<tflite::xnnpack::cache::schema::PackedWeights>(buf);
}

inline PackedWeights *GetMutablePackedWeights(void *buf) {
  return ::flatbuffers::GetMutableRoot<PackedWeights>(buf);
}

inline tflite::xnnpack::cache::schema::PackedWeights *GetMutableSizePrefixedPackedWeights(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<tflite::xnnpack::cache::schema::PackedWeights>(buf);
}

inline const char *PackedWeightsIdentifier() {
  return "V001";
}

inline bool PackedWeightsBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, PackedWeightsIdentifier());
}

inline bool SizePrefixedPackedWeightsBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, PackedWeightsIdentifier(), true);
}

inline bool VerifyPackedWeightsBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<tflite::xnnpack::cache::schema::PackedWeights>(PackedWeightsIdentifier());
}

inline bool VerifySizePrefixedPackedWeightsBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<tflite::xnnpack::cache::schema::PackedWeights>(PackedWeightsIdentifier());
}

inline const char *PackedWeightsExtension() {
  return "xnn_weights";
}

inline void FinishPackedWeightsBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<tflite::xnnpack::cache::schema::PackedWeights> root) {
  fbb.Finish(root, PackedWeightsIdentifier());
}

inline void FinishSizePrefixedPackedWeightsBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<tflite::xnnpack::cache::schema::PackedWeights> root) {
  fbb.FinishSizePrefixed(root, PackedWeightsIdentifier());
}

inline std::unique_ptr<tflite::xnnpack::cache::schema::PackedWeightsT> UnPackPackedWeights(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<tflite::xnnpack::cache::schema::PackedWeightsT>(GetPackedWeights(buf)->UnPack(res));
}

inline std::unique_ptr<tflite::xnnpack::cache::schema::PackedWeightsT> UnPackSizePrefixedPackedWeights(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<tflite::xnnpack::cache::schema::PackedWeightsT>(GetSizePrefixedPackedWeights(buf)->UnPack(res));
}

}  // namespace schema
}  // namespace cache
}  // namespace xnnpack
}  // namespace tflite

#endif  // FLATBUFFERS_GENERATED_WEIGHTCACHESCHEMA_TFLITE_XNNPACK_CACHE_SCHEMA_H_
