// RUN: hlo-opt %s --platform=gpu --stage=llvm-before-optimizations --xla_gpu_target_config_filename=%S/../../../tools/hlo_opt/gpu_specs/%{GPU}.txtpb | FileCheck --check-prefixes=CHECK,CHECK-%{PTX} %s

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// CHECK-LABEL: entry:
// CHECK:         %[[VAL_0:.*]] = alloca i8, align 1
// CHECK:         %[[VAL_1:.*]] = alloca i32, align 4
// CHECK:         %[[VAL_2:.*]] = alloca i1, align 1
// CHECK:         %[[VAL_3:.*]] = alloca i32, align 4
// CHECK:         %[[VAL_4:.*]] = alloca float, align 4
// CHECK-PTX:     %[[VAL_5:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x
// CHECK-GCN:     %[[VAL_5:.*]] = call i32 @llvm.amdgcn.workgroup.id.x
// CHECK-PTX:     %[[VAL_6:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x
// CHECK-GCN:     %[[VAL_6:.*]] = call i32 @llvm.amdgcn.workitem.id.x
// CHECK:         %[[VAL_7:.*]] = mul nuw nsw i32 %[[VAL_5]], 2
// CHECK:         %[[VAL_8:.*]] = add nuw nsw i32 %[[VAL_7]], %[[VAL_6]]
// CHECK:         %[[VAL_9:.*]] = icmp ult i32 %[[VAL_8]], 2
// CHECK:         call void @llvm.assume(i1 %[[VAL_9]])
// CHECK:         %[[VAL_10:.*]] = add nuw nsw i32 %[[VAL_8]], 0
// CHECK:         %[[VAL_11:.*]] = udiv i32 %[[VAL_10]], 1
// CHECK:         %[[VAL_12:.*]] = icmp ult i32 %[[VAL_8]], 2
// CHECK:         br i1 %[[VAL_12]], label %[[VAL_13:.*]], label %[[VAL_14:.*]]
// CHECK:       select_and_scatter_12.in_bounds-after:            ; preds = %[[VAL_15:.*]], %[[VAL_16:.*]]
// CHECK:         ret void
// CHECK:       select_and_scatter_12.in_bounds-true:             ; preds = %[[VAL_16]]
// CHECK-PTX:     store i1 false, ptr %[[VAL_2]], align 1
// CHECK-GCN:     store i1 false, ptr addrspace(5) %[[VAL_2]], align 1
// CHECK-PTX:     store i32 0, ptr %[[VAL_1]], align 4
// CHECK-GCN:     store i32 0, ptr addrspace(5) %[[VAL_1]], align 4
// CHECK:         br label %[[VAL_17:.*]]
// CHECK:       select_and_scatter_12inner.loop_header.window.0:  ; preds = %[[VAL_18:.*]], %[[VAL_13]]
// CHECK-PTX:     %[[VAL_19:.*]] = load i32, ptr %[[VAL_1]], align 4
// CHECK-GCN:     %[[VAL_19:.*]] = load i32, ptr addrspace(5) %[[VAL_1]], align 4
// CHECK:         %[[VAL_20:.*]] = icmp uge i32 %[[VAL_19]], 3
// CHECK:         br i1 %[[VAL_20]], label %[[VAL_21:.*]], label %[[VAL_22:.*]]
// CHECK:       select_and_scatter_12inner.loop_body.window.0:    ; preds = %[[VAL_17]]
// CHECK:         %[[VAL_23:.*]] = mul nsw i32 %[[VAL_11]], 3
// CHECK:         %[[VAL_24:.*]] = add nsw i32 %[[VAL_23]], %[[VAL_19]]
// CHECK:         %[[VAL_25:.*]] = sub nsw i32 %[[VAL_24]], 0
// CHECK:         %[[VAL_26:.*]] = icmp ult i32 %[[VAL_25]], 6
// CHECK:         %[[VAL_27:.*]] = and i1 true, %[[VAL_26]]
// CHECK:         br i1 %[[VAL_27]], label %[[VAL_28:.*]], label %[[VAL_29:.*]]
// CHECK:       in-bounds-after:                                  ; preds = %[[VAL_29]], %[[VAL_30:.*]]
// CHECK:         %[[VAL_31:.*]] = add nuw nsw i32 %[[VAL_19]], 1
// CHECK-PTX:     store i32 %[[VAL_31]], ptr %[[VAL_1]], align 4
// CHECK-GCN:     store i32 %[[VAL_31]], ptr addrspace(5) %[[VAL_1]], align 4
// CHECK:         br label %[[VAL_17]]
// CHECK:       select_and_scatter_12inner.loop_exit.window.0:    ; preds = %[[VAL_17]]
// CHECK-PTX:     %[[VAL_32:.*]] = load i1, ptr %[[VAL_2]], align 1
// CHECK-GCN:     %[[VAL_32:.*]] = load i1, ptr addrspace(5) %[[VAL_2]], align 1
// CHECK:         br i1 %[[VAL_32]], label %[[VAL_33:.*]], label %[[VAL_15]]
// CHECK:       should-store-after:                               ; preds = %[[VAL_33]], %[[VAL_21]]
// CHECK:         br label %[[VAL_14]]
// CHECK:       in-bounds-true:                                   ; preds = %[[VAL_22]]
// CHECK-PTX:     %[[VAL_34:.*]] = load i1, ptr %[[VAL_2]], align 1
// CHECK-GCN:     %[[VAL_34:.*]] = load i1, ptr addrspace(5) %[[VAL_2]], align 1
// CHECK:         br i1 %[[VAL_34]], label %[[VAL_35:.*]], label %[[VAL_36:.*]]
// CHECK:       initialized-after:                                ; preds = %[[VAL_36]], %[[VAL_37:.*]]
// CHECK:         br label %[[VAL_18]]
// CHECK:       in-bounds-false:                                  ; preds = %[[VAL_22]]
// CHECK:         br label %[[VAL_18]]
// CHECK:       initialized-true:                                 ; preds = %[[VAL_28]]
// CHECK:         %[[VAL_38:.*]] = getelementptr inbounds [6 x float], ptr %[[VAL_39:.*]], i32 0, i32 %[[VAL_25]]
// CHECK-GCN:     %[[VAL_4_2:.*]] = addrspacecast ptr addrspace(5) %[[VAL_4]] to ptr
// CHECK-GCN:     %[[VAL_0_2:.*]] = addrspacecast ptr addrspace(5) %[[VAL_0]] to ptr
// CHECK-GCN:     call void @ge_{{.*}}(ptr %[[VAL_4_2]], ptr %[[VAL_38]], ptr %[[VAL_0_2]])
// CHECK-PTX:     call void @ge_{{.*}}(ptr %[[VAL_4]], ptr %[[VAL_38]], ptr %[[VAL_0]])
// CHECK-PTX:     %[[VAL_40:.*]] = load i8, ptr %[[VAL_0]], align 1
// CHECK-GCN:     %[[VAL_40:.*]] = load i8, ptr addrspace(5) %[[VAL_0]], align 1
// CHECK:         %[[VAL_41:.*]] = icmp ne i8 %[[VAL_40]], 0
// CHECK:         br i1 %[[VAL_41]], label %[[VAL_42:.*]], label %[[VAL_43:.*]]
// CHECK:       if-select-lhs-after:                              ; preds = %[[VAL_43]], %[[VAL_42]]
// CHECK:         br label %[[VAL_30]]
// CHECK:       initialized-false:                                ; preds = %[[VAL_28]]
// CHECK:         %[[VAL_44:.*]] = getelementptr inbounds [6 x float], ptr %[[VAL_39]], i32 0, i32 %[[VAL_25]]
// CHECK:         %[[VAL_45:.*]] = load float, ptr %[[VAL_44]], align 4, !invariant.load
// CHECK-PTX:     store float %[[VAL_45]], ptr %[[VAL_4]], align 4
// CHECK-GCN:     store float %[[VAL_45]], ptr addrspace(5) %[[VAL_4]], align 4
// CHECK-PTX:     %[[VAL_46:.*]] = getelementptr inbounds i32, ptr %[[VAL_3]], i32 0
// CHECK-GCN:     %[[VAL_46:.*]] = getelementptr inbounds i32, ptr addrspace(5) %[[VAL_3]], i32 0
// CHECK-PTX:     store i32 %[[VAL_25]], ptr %[[VAL_46]], align 4
// CHECK-GCN:     store i32 %[[VAL_25]], ptr addrspace(5) %[[VAL_46]], align 4
// CHECK-PTX:     store i1 true, ptr %[[VAL_2]], align 1
// CHECK-GCN:     store i1 true, ptr addrspace(5) %[[VAL_2]], align 1
// CHECK:         br label %[[VAL_30]]
// CHECK:       if-select-lhs-true:                               ; preds = %[[VAL_35]]
// CHECK:         br label %[[VAL_37]]
// CHECK:       if-select-lhs-false:                              ; preds = %[[VAL_35]]
// CHECK:         %[[VAL_47:.*]] = load float, ptr %[[VAL_38]], align 4
// CHECK-PTX:     store float %[[VAL_47]], ptr %[[VAL_4]], align 4
// CHECK-GCN:     store float %[[VAL_47]], ptr addrspace(5) %[[VAL_4]], align 4
// CHECK-PTX:     %[[VAL_48:.*]] = getelementptr inbounds i32, ptr %[[VAL_3]], i32 0
// CHECK-GCN:     %[[VAL_48:.*]] = getelementptr inbounds i32, ptr addrspace(5) %[[VAL_3]], i32 0
// CHECK-PTX:     store i32 %[[VAL_25]], ptr %[[VAL_48]], align 4
// CHECK-GCN:     store i32 %[[VAL_25]], ptr addrspace(5) %[[VAL_48]], align 4
// CHECK:         br label %[[VAL_37]]
// CHECK:       should-store-true:                                ; preds = %[[VAL_21]]
// CHECK-PTX:     %[[VAL_49:.*]] = getelementptr inbounds i32, ptr %[[VAL_3]], i32 0
// CHECK-GCN:     %[[VAL_49:.*]] = getelementptr inbounds i32, ptr addrspace(5) %[[VAL_3]], i32 0
// CHECK-PTX:     %[[VAL_50:.*]] = load i32, ptr %[[VAL_49]], align 4
// CHECK-GCN:     %[[VAL_50:.*]] = load i32, ptr addrspace(5) %[[VAL_49]], align 4
// CHECK:         %[[VAL_51:.*]] = getelementptr float, ptr %[[VAL_52:.*]], i32 %[[VAL_8]]
// CHECK:         %[[VAL_53:.*]] = getelementptr inbounds float, ptr %[[VAL_51]], i32 0
// CHECK:         %[[VAL_54:.*]] = getelementptr inbounds [6 x float], ptr %[[VAL_55:.*]], i32 0, i32 %[[VAL_50]]
// CHECK:         %[[VAL_56:.*]] = load float, ptr %[[VAL_53]], align 4
// CHECK-GCN:     %[[VAL_54_2:.*]] = addrspacecast ptr %[[VAL_54]] to ptr addrspace(1)
// CHECK-GCN:     %[[VAL_57:.*]] = atomicrmw fadd ptr {{.*}} %[[VAL_54_2]], float %[[VAL_56]] {{.*}} seq_cst, align 4
// CHECK-PTX:     %[[VAL_57:.*]] = atomicrmw fadd ptr %[[VAL_54]], float %[[VAL_56]] seq_cst, align 4
// CHECK:         br label %[[VAL_15]]
// CHECK:       entry:
// CHECK:         %[[VAL_58:.*]] = alloca i8, align 1
// CHECK:         %[[VAL_59:.*]] = load float, ptr %[[VAL_60:.*]], align 4
// CHECK:         %[[VAL_61:.*]] = load float, ptr %[[VAL_62:.*]], align 4
// CHECK:         %[[VAL_63:.*]] = fcmp oge float %[[VAL_59]], %[[VAL_61]]
// CHECK:         %[[VAL_64:.*]] = zext i1 %[[VAL_63]] to i8
// CHECK-PTX:     store i8 %[[VAL_64]], ptr %[[VAL_58]], align 1
// CHECK-GCN:     store i8 %[[VAL_64]], ptr addrspace(5) %[[VAL_58]], align 1
// CHECK-PTX:     %[[VAL_65:.*]] = load i8, ptr %[[VAL_58]], align 1
// CHECK-GCN:     %[[VAL_65:.*]] = load i8, ptr addrspace(5) %[[VAL_58]], align 1
// CHECK:         store i8 %[[VAL_65]], ptr %[[VAL_66:.*]], align 1
// CHECK:         ret void

HloModule SelectAndScatter, is_scheduled=true

%ge_F32 (lhs.5: f32[], rhs.6: f32[]) -> pred[] {
  %lhs.5 = f32[] parameter(0)
  %rhs.6 = f32[] parameter(1)
  ROOT %compare.7 = pred[] compare(f32[] %lhs.5, f32[] %rhs.6), direction=GE
}

%add_F32 (lhs.9: f32[], rhs.10: f32[]) -> f32[] {
  %lhs.9 = f32[] parameter(0)
  %rhs.10 = f32[] parameter(1)
  ROOT %add.11 = f32[] add(f32[] %lhs.9, f32[] %rhs.10)
}

ENTRY main () -> f32[6] {
  %operand = f32[6]{0} parameter(0)
  %source = f32[2]{0} parameter(1)
  %init = f32[] constant(0)
  ROOT %select_and_scatter_12 = f32[6]{0} select-and-scatter(f32[6]{0} %operand, f32[2]{0} %source, f32[] %init), window={size=3 stride=3}, select=%ge_F32, scatter=%add_F32
}
